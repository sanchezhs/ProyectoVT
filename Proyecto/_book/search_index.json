[["analizando-el-ssdeep.html", "Chapter 2 Analizando el ssdeep 2.1 sample1.c 2.2 sample2.c 2.3 sample3.c 2.4 Analizando los json", " Chapter 2 Analizando el ssdeep Las funciones hash como MD5, SHA256 o otras son útiles si queremos verificar la integridad de un archivo, su principio fundamental es que un pequeño cambio en el archivo (del orden de unos pocos bits) cambia la salida drásticamente. En nuestro caso si queremos encontrar similitud entre malware no podemos usar esas funciones, porque si sabemos con certeza de que cierto archivo es peligroso y tenemos su hash calculado, con cambiar un bit de ese archivo ya no lo podríamos detectar. Por ello existe el programa ssdeep, que permite observar pequeñas diferencias entre archivos calculando el CTPH (parecido al hash). 2.1 sample1.c #include &lt;stdio.h&gt; void main() { printf (“Hello World”); } 2.2 sample2.c #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { for (int i = 0; i &lt; 100; i++) { if (i%2 == 0) { i = i + 1; } } return 0; } 2.3 sample3.c #include &lt;stdio.h&gt; void main() { int a = 5; printf (“Hello World: %d\\n”, a); } Ahora calculamos y comparamos el ssdeep de los tres programas: $ ssdeep -s * &gt; sample_ctph.ssd $ ssdeep -m sample_ctph.ssd -s * Obtenemos lo siguiente: $ sample1 matches sample_ctph.ssd:/home/samuel/Documentos/LCC/pruebas/sample1 (100) $ sample1 matches sample_ctph.ssd:/home/samuel/Documentos/LCC/pruebas/sample2 (63) $ sample1 matches sample_ctph.ssd:/home/samuel/Documentos/LCC/pruebas/sample3 (80) sample1.c es mucho más parecido a sample3.c (en un 80%, mientras que solo un 63% con sample2.c). 2.4 Analizando los json Primero cargamos el directorio Android y el dataframe preprocesado. path &lt;- &quot;~/Documentos/LCC/ProyectoVT/Proyecto/Android2/&quot; nombres_ficheros &lt;- list.files(path) df &lt;- read_csv(&quot;~/Documentos/LCC/ProyectoVT/Proyecto/virusTotal.csv&quot;) ## New names: ## Rows: 183 Columns: 10 ## ── Column specification ## ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr ## (2): submission.submitter_country, additional_info.exiftool.FileType dbl (6): ## ...1, total, size, times_submitted, positives, Year dttm (2): scan_date, ## first_seen ## ℹ Use `spec()` to retrieve the full column specification for this data. ℹ ## Specify the column types or set `show_col_types = FALSE` to quiet this message. ## • `` -&gt; `...1` #df_deep &lt;- read.csv(&quot;~/Documentos/LCC/ProyectoVT/Proyecto/analisis_ssdeep.csv&quot;) Para analizar nuestros json, desarrollamos primero la siguiente función que para cada archivo saca su sdeep y crea un dataframe: # Entrada: json # Salida: dataframe get_ssdeep &lt;- function(x) { json &lt;- read_json(x) res &lt;- json %&gt;% gather_object() %&gt;% filter(name == &#39;ssdeep&#39;) %&gt;% as.data.frame() return (res) } # Por cada archivo en la carpeta Android # coge su ssdeep y los guarda en un dataframe df_deep &lt;- data.frame() for (i in nombres_ficheros) { df_deep &lt;- rbind(df_deep, get_ssdeep(paste0(path,i))) } # Limpia el dataframe df_deep &lt;- df_deep %&gt;% select(..JSON) colnames(df_deep) &lt;- (&#39;ssdeep&#39;) Leemos los dataframes, df_deep contiene los hashes CTPH: # Coge los virus cuya distancia (parecido) # en sus ssdeep sea menor que 2 # y los guarda en *indices* indices &lt;- c() for (i in 1:nrow(df_deep)) { for (j in (i+1):nrow(df_deep)) { if ( adist(df_deep[i,], df_deep[j,]) == 1) { indices &lt;- c(indices, i,j) } } } 2.4.1 Matriz de adyacencias Creamos una matriz de adyacencias con todos los json, donde la posicion Mij = 1 si la distancia entre los hashes del archivo i y el 1 es igual a uno. M &lt;- matrix(0, nrow = nrow(df), ncol = nrow(df)) j &lt;- 1 while(j &lt; length(indices)) { M[indices[j], indices[j+1]] &lt;- 1 j &lt;- j+2 } 2.4.2 Grafos Dibujamos el siguiente grafo donde los vértices indican el json y las aristas su simulitud. Esto quiere decir que, por ejemplo, el grupo amarillo (147, 153 y 46) comparte gran parte de código, y lo mismo para con los otros dos grupos. G &lt;- graph_from_adjacency_matrix(M, mode = &#39;undirected&#39;) Isolated = which(degree(G)==0) G2 = delete.vertices(G, Isolated) groupList &lt;- list(g1 = c(3, 5), g2 = c(1, 7, 6), g3 = c(2,4)) groupColours &lt;- c(rgb(0,0.3,1,0.5), rgb(0.8,0.4,0.1,0.5), rgb(0.0,0.4,0.1,0.5)) plot(G2, vertex.color=&#39;#ADD8E6&#39;, edge.curved = .1, vertex.size=20, vertex.label=indices[V(G2)], edge.label=rep(1, length(indices)-1), mark.groups=groupList, mark.col= groupColours ) "]]
