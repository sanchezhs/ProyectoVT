[["analizando-el-ssdeep.html", "Chapter 2 Analizando el ssdeep 2.1 sample1.c 2.2 sample2.c 2.3 sample3.c 2.4 Analizando los json 2.5 Grafos 2.6 Grafo completo, G1 2.7 Grafo de distancias &lt;= 10 para G 2.8 Análisis del mayor componente de G 2.9 Analizando los resultados de los antivirus de G", " Chapter 2 Analizando el ssdeep Las funciones hash como MD5, SHA256 o otras son útiles si queremos verificar la integridad de un archivo, su principio fundamental es que un pequeño cambio en el archivo (del orden de unos pocos bits) cambia la salida drásticamente. En nuestro caso si queremos encontrar similitud entre malware no podemos usar esas funciones, porque si sabemos que un archivo es peligroso y tenemos su hash calculado, con cambiar un bit de ese archivo ya no lo podríamos detectar. Por eso existe el programa ssdeep, que permite observar pequeñas diferencias entre archivos calculando el CTPH (parecido al hash). Tenemos tres programas de ejemplo escritos en C, y queremos ver en qué porcentaje se parecen. 2.1 sample1.c #include &lt;stdio.h&gt; void main() { printf (“Hello World”); } 2.2 sample2.c #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { for (int i = 0; i &lt; 100; i++) { if (i%2 == 0) { i = i + 1; } } return 0; } 2.3 sample3.c #include &lt;stdio.h&gt; void main() { int a = 5; printf (“Hello World: %d\\n”, a); } Calculamos y comparamos el ssdeep de los tres programas: $ ssdeep -s * &gt; sample_ctph.ssd $ ssdeep -m sample_ctph.ssd -s * Obtenemos lo siguiente: $ sample1 matches sample_ctph.ssd:/home/samuel/Documentos/LCC/pruebas/sample1 (100) $ sample1 matches sample_ctph.ssd:/home/samuel/Documentos/LCC/pruebas/sample2 (63) $ sample1 matches sample_ctph.ssd:/home/samuel/Documentos/LCC/pruebas/sample3 (80) sample1.c es mucho más parecido a sample3.c (en un 80%, mientras que solo un 63% con sample2.c). 2.4 Analizando los json De la misma manera, primero cargamos el directorio Android y el dataframe preprocesado, y luego calculamos el hash como con los ejemplos. path &lt;- &quot;~/Documentos/LCC/ProyectoVT/Proyecto/Android2/&quot; nombres_ficheros &lt;- list.files(path) df &lt;- read_csv(&quot;~/Documentos/LCC/ProyectoVT/Proyecto/virusTotal.csv&quot;) #df_deep &lt;- read.csv(&quot;~/Documentos/LCC/ProyectoVT/Proyecto/analisis_ssdeep.csv&quot;) Dentro del json, hay un par clave valor que almacena el CTPH calculado (ssdeep), así que para analizarlo, escribimos primero la siguiente función que crea un dataframe con todos los json: # Entrada: json # Salida: dataframe get_ssdeep &lt;- function(x) { json &lt;- read_json(x) res &lt;- json %&gt;% gather_object() %&gt;% filter(name == &#39;ssdeep&#39;) %&gt;% as.data.frame() return (res) } # Por cada archivo en la carpeta Android # coge su ssdeep y los guarda en un dataframe df_deep &lt;- data.frame() for (i in nombres_ficheros) { df_deep &lt;- rbind(df_deep, get_ssdeep(paste0(path,i))) } # Limpia el dataframe df_deep &lt;- df_deep %&gt;% select(..JSON) colnames(df_deep) &lt;- (&#39;ssdeep&#39;) Una vez tenemos los datos, comparamos dos a dos todos los ssdeep usando la función adist y almacenamos los índices y su distancia. Índices contiene la distancia del json i con el j para luego construir una matriz. # Coge los virus cuya distancia (parecido) # en sus ssdeep sea menor que 2 # y los guarda en *indices* indices &lt;- c() for (i in 1:nrow(df_deep)) { for (j in (i+1):nrow(df_deep)) { if ( adist(df_deep[i,], df_deep[j,]) == 1) { indices &lt;- c(indices, i,j) } } } 2.4.1 Matriz de adyacencias Creamos una matriz de adyacencias con todos los json, donde en este caso la posicion Mij = 1 si la distancia entre los hashes del archivo i y el j es igual a uno. Cuanto menor es la distancia, menos diferencia hay entre los hashes y más código comparten. n &lt;- nrow(df) Mat &lt;- matrix(0, nrow = n, ncol = n) colnames(Mat) &lt;- c(1:n) row.names(Mat) &lt;- c(1:n) j &lt;- 1 while(j &lt; length(indices)) { Mat[indices[j], indices[j+1]] &lt;- 1 j &lt;- j+2 } Teniendo la matriz de adyacencias el siguiente paso es construir el grafo. Cada vértice es un json, y los arcos conectan json cuya distancia recibe por parámetro get_adj_matrix. Una vez se crea el grafo añadimos un atributo a las aristas con su distancia. # Entrada: distancia entre json # Salida: Grafo=(V,E) # V = json # E = distancias (ssdeep) get_adj_matrix &lt;- function(distancia) { indices &lt;- c() distancias &lt;- c() for (i in 1:nrow(df_deep)) { for (j in (i+1):nrow(df_deep)) { if ( adist(df_deep[i,], df_deep[j,]) &lt;= distancia) { indices &lt;- c(indices, i,j) distancias &lt;- c(distancias, adist(df_deep[i,], df_deep[j,])) } } } n &lt;- nrow(df) Mat &lt;- matrix(0, nrow = n, ncol = n) colnames(Mat) &lt;- c(1:n) row.names(Mat) &lt;- c(1:n) j &lt;- 1 while(j &lt; length(indices)) { Mat[indices[j], indices[j+1]] &lt;- 1 j &lt;- j+2 } G &lt;- graph_from_adjacency_matrix(Mat, mode = &#39;undirected&#39;) G &lt;- set_edge_attr(G, &#39;dist&#39;, value=distancias) return(G) } 2.5 Grafos Dibujamos el siguiente grafo con aquellos json cuyas distancias son menores o iguales que uno. Esto quiere decir que, por ejemplo, el grupo 147, 153 y 46 comparte gran parte de código. G &lt;- get_adj_matrix(1) Isolated = which(degree(G)==0) G2 = delete.vertices(G, Isolated) plot(G2, vertex.color=&#39;#ADD8E6&#39;, edge.curved = .1, vertex.size=20, edge.label=E(G2)$dist, vertex.frame.color = NA, layout=layout_nicely ) title(&quot;Distancias &lt;= 1&quot;,cex.main=1,col.main=&quot;Black&quot;) 2.6 Grafo completo, G1 Vamos a ver qué grafo se dibuja si restringimos menos la búsqueda y ponemos que saque todos los archivos que se parezcan como mínimo en un 60%. G1 &lt;- get_adj_matrix(60) plot(G1) title(&quot;Grafo completo con distancia &lt;= 60&quot;,cex.main=1,col.main=&quot;Black&quot;) Se pueden ver varios grupos que forman componentes y muchos otros nodos aislados. Esto puede deberse a que los componentes corresponden a alguna variante del mismo malware. Calculamos los componentes y guardamos los nodos de aquel más grande. c1 &lt;- components(G1) biggest1 &lt;- which.max(c1$csize) vids1 &lt;- V(G1)[c1$membership==biggest1] Dibujamos el subgrafo. plot(induced_subgraph(G1, vids1), edge.label=E(G1)$dist) title(&quot;Mayor componente con pesos&quot;,cex.main=1,col.main=&quot;Black&quot;) plot(induced_subgraph(G1, vids1), vertex.size=25) title(&quot;Mayor componente sin pesos&quot;,cex.main=1,col.main=&quot;Black&quot;) plot(induced_subgraph(G1, vids1),vertex.size = 5, vertex.color = &quot;#1e3f66&quot;, vertex.frame.color = &#39;red&#39;, vertex.label.cex = .7, vertex.label = NA, edge.curved = .5, edge.arrow.size = .3, edge.width = .7) title(&quot;Mayor componente&quot;,cex.main=1,col.main=&quot;Black&quot;) 2.6.1 Análisis del componente Usando el algoritmo pagerank y la función grado, ordenamos los nodos por importancia: subgrafo &lt;- induced_subgraph(G1, vids1) pg &lt;- page.rank(subgrafo) importancia &lt;- data.frame( grado = degree(subgrafo), page_rank = pg$vector ) importancia_sorted &lt;- data.frame( grado = sort(degree(subgrafo), decreasing = TRUE), page_rank = sort(pg$vector, decreasing = TRUE) ) knitr::kable(head(importancia_sorted, 10)) grado page_rank 82 62 0.0197978 163 61 0.0196663 47 60 0.0190018 124 59 0.0181018 111 58 0.0180970 154 58 0.0176471 54 57 0.0174520 39 56 0.0170076 67 56 0.0170076 115 55 0.0166772 Resaltamos los nodos con grado mayor que cincuenta: plot(subgrafo, vertex.size=ifelse(importancia[V(subgrafo),][1]&gt;50,5, 1), vertex.label=NA, edge.curved = .5, edge.arrow.size = .3, edge.width = .7) Si vemos los tamaños de los componentes, hay uno con doce nodos: c1$csize ## [1] 3 3 99 1 1 1 1 2 1 1 1 12 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [26] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [51] 2 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 Lo dibujamos, en este caso los json comparten aproximadamente la mitad de código. vids2 &lt;- V(G1)[c1$membership==12] plot(induced_subgraph(G1, vids2), edge.label=E(G1)$dist, vertex.size=20) 2.6.2 Algunos gráficos de G1 A continuación se muestran gráficas del componente grande de G1. Transformamos las fechas a formato date para poder dibujarlas. # Comparacion del componente grande de G1 v &lt;- as(vids1, &#39;vector&#39;) df_grafo &lt;- subset(df, row.names(df) %in% v) library(plotly) df_grafo$scan_date &lt;- as.POSIXct(df_grafo$scan_date, format=&quot;%Y-%m-%d %H:%M:%S&quot;) df_grafo$first_seen &lt;- as.POSIXct(df_grafo$first_seen, format=&quot;%Y-%m-%d %H:%M:%S&quot;) colnames(df_grafo)[8] &lt;- &#39;Pais&#39; Positivos a lo largo del tiempo (fecha de escáner). p &lt;- ggplot(df_grafo, aes(x=scan_date, y=positives)) + geom_line() + ylab(&#39;Positivos&#39;) + xlab(&#39;Fecha de escáner&#39;) + theme_bw() ggplotly(p) Tamaño de los json a lo largo del tiempo (fecha de escáner). p2 &lt;- ggplot(df_grafo, aes(x=scan_date, y=size)) + geom_line() + ylab(&#39;Tamaño&#39;) + xlab(&#39;Primera vez subido&#39;) + theme_bw() ggplotly(p2) Positivos a lo largo del tiempo (primera vez que se subió). p3 &lt;- ggplot(df_grafo, aes(x=first_seen, y=positives)) + geom_line() + ylab(&#39;Positivos&#39;) + xlab(&#39;Tiempo&#39;) + theme_bw() ggplotly(p3) Regiones desde donde se subió: df_grafo %&gt;% select(times_submitted, Pais) %&gt;% group_by(Pais) %&gt;% summarise(times_submitted=sum(times_submitted)) %&gt;% ggplot(data=., aes(y=times_submitted)) + geom_bar(mapping = aes(fill=Pais, x=Pais), stat = &#39;identity&#39;) + theme_bw() Como los datos no están a escala, sumamos uno y aplicamos logaritmo para compararlos mejor: p_regiones &lt;- df_grafo %&gt;% select(times_submitted, Pais) %&gt;% group_by(Pais) %&gt;% summarise(times_submitted=sum(times_submitted)) %&gt;% ggplot(data=., aes(y=log(1+times_submitted))) + geom_bar(mapping = aes(fill=Pais, x=Pais), stat = &#39;identity&#39;) + ylab(&#39;Veces subido&#39;) + xlab(&#39;País&#39;) + theme_bw() ggplotly(p_regiones) Visualizamos el número de positivos por país: p_positivos_pais &lt;- df_grafo %&gt;% select(positives, Pais) %&gt;% group_by(Pais) %&gt;% summarise(positives=sum(positives)) %&gt;% ggplot(data=., aes(y=positives)) + geom_bar(mapping = aes(fill=Pais, x=Pais), stat = &#39;identity&#39;) + ylab(&#39;Positivos&#39;) + xlab(&#39;País&#39;) + theme_bw() ggplotly(p_positivos_pais) 2.7 Grafo de distancias &lt;= 10 para G Calculamos y dibujamos las componentes del grafo con distancias menores o iguales que diez. G &lt;- get_adj_matrix(10) c &lt;- components(G) biggest &lt;- which.max(c$csize) vids &lt;- V(G)[c$membership==biggest] plot(induced_subgraph(G, vids), edge.label=E(G)$dist) title(&quot;Distancias &lt;= 10 con pesos&quot;,cex.main=1,col.main=&quot;Black&quot;) plot(induced_subgraph(G, vids), vertex.size=25) title(&quot;Distancias &lt;= 10 sin pesos&quot;,cex.main=1,col.main=&quot;Black&quot;) plot(induced_subgraph(G, vids),vertex.size = 10, vertex.color = &quot;#1e3f66&quot;, vertex.frame.color = &#39;blue&#39;, vertex.label.cex = .7, vertex.label = NA, edge.curved = .5, edge.arrow.size = .3, edge.width = .7) title(&quot;Distancias &lt;= 10&quot;,cex.main=1,col.main=&quot;Black&quot;) 2.8 Análisis del mayor componente de G Todos los archivos tienen el mismo tamaño, subidos desde California en menos de una hora. Con una media de 20 positivos, probablemente sean el mismo archivo. v &lt;- as(vids, &#39;vector&#39;) compare &lt;- data.frame() for (i in v) { compare &lt;- rbind(compare, df[i,]) } compare %&gt;% select(size) %&gt;% unique() ## # A tibble: 1 × 1 ## size ## &lt;dbl&gt; ## 1 2669106 compare %&gt;% select(submission.submitter_country) %&gt;% unique() ## # A tibble: 1 × 1 ## submission.submitter_country ## &lt;chr&gt; ## 1 CA times &lt;- compare %&gt;% select(first_seen, scan_date) %&gt;% mutate(first_seen = gsub(&#39;20[0-9]{2}-[0-9]+-[0-9]+&#39;, &#39;&#39;, first_seen), scan_date = gsub(&#39;20[0-9]{2}-[0-9]+-[0-9]+&#39;, &#39;&#39;, scan_date)) Primera y última vez que se subió: lapply(times[,1], max) ## $first_seen ## [1] &quot; 00:46:00&quot; lapply(times[,1], min) ## $first_seen ## [1] &quot; 00:19:22&quot; Media: # Media compare %&gt;% select(positives) %&gt;% lapply(., mean) ## $positives ## [1] 19.85185 Desviación típica: # Desviación típica compare %&gt;% select(positives) %&gt;% lapply(., sd) ## $positives ## [1] 1.610153 2.9 Analizando los resultados de los antivirus de G Vamos a ver qué resultado da cada antivirus a los json (vértices) del grafo G. Si dos antivirus dan el mismo resultado en archivos diferentes que sabemos que son casi iguales es probable que compartan motor. La siguiente función recorre el directorio del dataset y crea un dataframe con los antivirus. # Entrada: Ruta al fichero # Salida: Dataframe con resultados de los AV get_results &lt;- function(json) { json_data &lt;- tidyjson::read_json(json) df_temp &lt;- json_data %&gt;% gather_object() %&gt;% filter(name==&#39;scans&#39;) %&gt;% spread_all() %&gt;% gather_object() %&gt;% select(ends_with(&#39;result&#39;)) %&gt;% .[1,] %&gt;% select(-last_col()) return(df_temp) } vids tiene los vértices de los grafos calculados. Pasamos los nombres a formato numérico con ceros a la izquierda. ficheros &lt;- sapply(vids, function(x) paste0(sprintf(&quot;%04d&quot;, x), &#39;.json&#39;) ) Creamos un dataframe y, por cada vértice, cogemos los escáneres. df_results &lt;- data.frame() for (i in ficheros) { df_results &lt;- rbind.fill(df_results, get_results(paste0(path,i))) } write.csv(df_results, &quot;~/Documentos/LCC/ProyectoVT/Proyecto/escaneres.csv&quot;) Leemos y limpiamos el dataframe. df_results &lt;- read_csv(&quot;~/Documentos/LCC/ProyectoVT/Proyecto/escaneres.csv&quot;) #df_results &lt;- df_results %&gt;% select(-..JSON) colnames(df_results) &lt;- lapply(colnames(df_results), function(x) gsub(&#39;.result&#39;, &#39;&#39;, x)) # Quitar columnas enteras NA df_results &lt;- df_results[, colSums(is.na(df_results)) != nrow(df_results)] df_results &lt;- df_results %&gt;% select(-...1) Cogemos la columna trece, que no tiene valores NA. Como en realidad todas las columnas son el mismo archivo con ver una sola nos sirve, y podemos ver cómo cada antivirus (excepto los que comparten motor) lo clasifican de manera distinta. j107 &lt;- df_results[13,] j107 &lt;- t(j107) knitr::kable(j107, col.names = c(&#39;0107.json&#39;)) 0107.json Lionic Trojan.AndroidOS.Wapnor.C!c ClamAV NA CAT-QuickHeal NA McAfee Artemis!46B876999B18 VIPRE NA Sangfor Malware.Generic-Script.Save.5b333b13 Alibaba NA K7GW Trojan ( 0051a3c71 ) Trustlook NA Arcabit NA Cyren AndroidOS/GhostPush.C.gen!Eldorado SymantecMobileInsight NA Symantec Trojan.Gen.MBT ESET-NOD32 a variant of Android/TrojanDropper.Shedun.V TrendMicro-HouseCall NA Avast Android:Revo-OU [Trj] Cynet Malicious (score: 99) Kaspersky HEUR:Trojan-Dropper.AndroidOS.Wapnor.a BitDefender NA NANO-Antivirus Trojan.Android.MLW.ebzlbe MicroWorld-eScan NA Rising NA Ad-Aware NA Emsisoft NA Comodo NA F-Secure Malware.ANDROID/Agent.hutg DrWeb Android.DownLoader.329.origin Zillya Dropper.Shedun.Android.200569 TrendMicro NA McAfee-GW-Edition Artemis!Trojan FireEye NA Sophos NA Ikarus Trojan-Dropper.AndroidOS.Shedun Avast-Mobile Android:Shedun-V [Trj] Jiangmin NA Avira ANDROID/Agent.hutg Antiy-AVL Trojan/Generic.ASBOL.A0C1 Kingsoft NA Microsoft TrojanDropper:AndroidOS/Shedun.A!MTB ZoneAlarm NA GData NA BitDefenderFalx NA AhnLab-V3 PUP/Android.Agent.839002 Tencent Dos.Trojan-dropper.Piom.Pege Yandex NA MAX malware (ai score=95) MaxSecure Android.wapnor.a Fortinet Android/Shedun.AC!tr AVG Android:Revo-OU [Trj] Si seleccionamos los AV Kasperky y ZoneAlarm se observa fácilmente que los resultados son idénticos y seguramente compartan el mismo motor. df_results %&gt;% select(Kaspersky, ZoneAlarm) %&gt;% head(., 10) %&gt;% knitr::kable(.) Kaspersky ZoneAlarm HEUR:Trojan-Dropper.AndroidOS.Hqwar.bk HEUR:Trojan-Dropper.AndroidOS.Hqwar.bk not-a-virus:HEUR:AdWare.AndroidOS.Ewind.kp NA not-a-virus:UDS:AdWare.AndroidOS.Ewind.kp not-a-virus:HEUR:AdWare.AndroidOS.Ewind.kp HEUR:Trojan-Dropper.AndroidOS.Wapnor.a NA not-a-virus:HEUR:AdWare.AndroidOS.Ewind.kp NA HEUR:Trojan-Banker.AndroidOS.Fakecalls.k HEUR:Trojan-Banker.AndroidOS.Fakecalls.k not-a-virus:HEUR:AdWare.AndroidOS.Adlo.b NA NA NA not-a-virus:HEUR:AdWare.AndroidOS.Ewind.kp not-a-virus:HEUR:AdWare.AndroidOS.Ewind.kp HEUR:Trojan.AndroidOS.Agent.aw HEUR:Trojan.AndroidOS.Agent.aw McAfee y McAfee GW Edition también, normal porque ambos son de McAfee df_results %&gt;% select(McAfee, `McAfee-GW-Edition`) %&gt;% head(., 10) %&gt;% knitr::kable(.) McAfee McAfee-GW-Edition Artemis!BF3E6F490724 NA Artemis!919A1900C529 Artemis Artemis!919A1900C529 Artemis Artemis!1E07E4821182 Artemis!Trojan Artemis!919A1900C529 Artemis NA NA Artemis!0C5C3D793761 Artemis!PUP Artemis!4EF2BDF37187 Artemis Artemis!919A1900C529 Artemis Artemis!19295D19D0AC Artemis!Trojan "]]
